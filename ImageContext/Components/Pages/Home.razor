@page "/"
@using System.Data
@using ExifLib
@using Google
@using ImageContext.Components.Services
@using ImageMagick
@using Google.Apis.CustomSearchAPI;
@using Google.Apis.CustomSearchAPI.v1
@using Google.Apis.Services
@using OpenAI_API

@rendermode InteractiveServer

@inject GoogleServices googleServices;
@inject OpenAIService openAIService;
@inject WeatherService weatherService;


<PageTitle>Home</PageTitle>

<div>Select your file:</div>
<InputFile OnChange="FileUploaded" accept="image/*" />
<p role="status">Message: @_resultMessage</p>

<img src="@imageSource" alt="{@_address} on {@_dateTaken}" />
<p>Date Taken: @_dateTaken</p>
<p>Coordinates: @_coordinateString</p>
<p>Temperature: @_weatherResult.temp Feels Like: @_weatherResult.feelsLikeTemp Humidity: @_weatherResult.humidity Wind Speed: @_weatherResult.windSpeed Description: @_weatherResult.description</p>
<p>Address: @_address</p>
<p>History: @_historyOfAddress</p>
<a href="@_twitterResultsUrl">Twitter Feed</a>
<p>Search Term: @_searchTerm</p>
<p>Results:</p>
<br/>
@foreach (var webResult in _webResults)
{
    <img src="@webResult.thumbnailUrl" alt="@webResult.title"/>
    <p>@webResult.title</p>
    <p>@webResult.snippet</p>
    <a href="@webResult.link">@webResult.link</a>
    <br/>
}

@code {
    
    private DateTime lastSubmissionTime = DateTime.MinValue;
    
    // Example byte array for demonstration
    private byte[] imageBytes;

    private string imageBase64Data;
    private string imageMimeType = "image/jpeg"; // Adjust based on the image type
    private string imageSource;

    ExifExtractService.ImageMetadata imageMetadata;
    private string _dateTaken;
    private string _coordinateString;
    private string _places;
    private string _address;
    private string _searchTerm;
    private string _historyOfAddress;
    private string _twitterResultsUrl = "";
    private List<WebResult> _webResults = new List<WebResult>();
    private WeatherResult _weatherResult = new WeatherResult();
    
    private string _resultMessage = "Waiting for file upload...";
    private const string SuccessMessage = "Image uploaded successfully";
    private const string InvalidFileMessage = "Error: Invalid file type";
    private const string NullMetadataMessage = "Error: Metadata not available";

    private async Task FileUploaded(InputFileChangeEventArgs e)
    {
        // Return if not a heif or jpeg file
        if (e.File.ContentType != "image/heif" && e.File.ContentType != "image/jpeg")
        {
            _resultMessage = InvalidFileMessage;
            return;
        }

        try
        {
            if (DateTime.Now < lastSubmissionTime.AddSeconds(45))
            {
                throw new Exception("Please wait before submitting another photo.");
            }

            // Update the last submission time
            lastSubmissionTime = DateTime.Now;
            
            // Read the file into a memory stream
            using var stream = new MemoryStream();
            await e.File.OpenReadStream(maxAllowedSize: 1024 * 6000).CopyToAsync(stream);
            stream.Position = 0;
            Console.WriteLine("Read file into memory stream");
            
            using var image = new MagickImage(stream);
            if (e.File.ContentType == "image/heif")
            {
                // Convert image to Jpg, flush stream, rewrite image to stream
                image.Format = MagickFormat.Jpg;
                await stream.FlushAsync();
                await image.WriteAsync(stream);
                stream.Position = 0;
            }
            image.Resize(512,512);
            imageBytes = image.ToByteArray();
            imageBase64Data = Convert.ToBase64String(imageBytes);
            imageSource = $"data:image/jpeg;base64,{imageBase64Data}";
            stream.Position = 0;
            
            // Extract EXIF data from stream
            imageMetadata = await new ExifExtractService().ExtractExifData(stream);
            
            _resultMessage = SuccessMessage;

            if (imageMetadata.DateTaken != null)
            {
                _dateTaken = imageMetadata.DateTaken.ToString();
            }
            else
            {
                _dateTaken = NullMetadataMessage;
            }

            if (imageMetadata.Coordinates != null)
            {
                var lat = imageMetadata.Coordinates.Value.Item1.ToString();
                var lng = imageMetadata.Coordinates.Value.Item2.ToString();
                _coordinateString = $"Latitude: {lat} Longitude: {lng}";
                var geocodingData = await googleServices.GeocodingApi(lat,lng);
                
                var formatedAddresses = geocodingData;

                var year = imageMetadata.DateTaken.Year;
                var month = imageMetadata.DateTaken.Month;
                var day = imageMetadata.DateTaken.Day;

                _twitterResultsUrl = $"https://twitter.com/search?q=+geocode%3A{imageMetadata.Coordinates.Value.Item1}%2C{imageMetadata.Coordinates.Value.Item2}%2C2mi+since%3A{year}-{month}-{day-1}+until%3A{year}-{month}-{day+1}&src=typed_query";
                
                _address = await openAIService.AddressCorrection(formatedAddresses, imageBytes);
                _historyOfAddress = await openAIService.HistoryOfAddress(_address);
                _searchTerm = await openAIService.CreateOptimalSearchTerm(_address);

                _webResults = await googleServices.SearchApi(_searchTerm, imageMetadata.DateTaken);

                _weatherResult = await weatherService.GetWeatherDateLocation(lat, lng, imageMetadata.DateTaken);
            }
            else
            {
                _coordinateString = NullMetadataMessage;
                _places = NullMetadataMessage;
                _address = NullMetadataMessage;
            }
        }
        catch (ExifLibException ex)
        {
            _resultMessage = $"Error: {ex.Message}";
        }
        catch (Exception ex)
        {
            _resultMessage = $"Error: {ex.Message}";
        }
        
        
    }
}