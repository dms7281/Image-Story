@page "/"
@using System.Data
@using ExifLib
@using Google
@using ImageContext.Components.Services
@using ImageMagick
@using Google.Apis.CustomSearchAPI;
@using Google.Apis.CustomSearchAPI.v1
@using Google.Apis.Services
@using OpenAI_API

@rendermode InteractiveServer

@inject GoogleServices googleServices;
@inject OpenAIService openAIService;


<PageTitle>Home</PageTitle>

<img src="@imageSource" alt="{@_address} on {@_dateTaken}" />

<div>Select your file:</div>
<InputFile OnChange="FileUploaded" accept="image/*" />
<p role="status">Message: @_resultMessage</p>
<p>Date Taken: @_dateTaken</p>
<p>Coordinates: @_coordinateString</p>
<p>Simplified Address: @_address</p>
<p>Search Terms: @_searchTerms</p>
<p>History: @_historyOfAddress</p>
<a href="@_twitterResultsUrl">Twitter Feed</a>

@code {
    private readonly HttpClient _httpClient = new HttpClient();
    
    // Example byte array for demonstration
    private byte[] imageBytes;

    private string imageBase64Data;
    private string imageMimeType = "image/jpeg"; // Adjust based on the image type
    private string imageSource;

    ExifExtractService.ImageMetadata imageMetadata;
    private string _dateTaken;
    private string _coordinateString;
    private string _places;
    private string _address;
    private string _searchTerms;
    private string _historyOfAddress;
    private string _twitterResultsUrl = "";
    
    private string _resultMessage = "Waiting for file upload...";
    private const string SuccessMessage = "Image uploaded successfully";
    private const string InvalidFileMessage = "Error: Invalid file type";
    private const string NullMetadataMessage = "Error: Metadata not available";

    private async Task FileUploaded(InputFileChangeEventArgs e)
    {
        // Return if not a heif or jpeg file
        if (e.File.ContentType != "image/heif" && e.File.ContentType != "image/jpeg")
        {
            _resultMessage = InvalidFileMessage;
            return;
        }

        try
        {
            // Read the file into a memory stream
            using var stream = new MemoryStream();
            await e.File.OpenReadStream(maxAllowedSize: 1024 * 6000).CopyToAsync(stream);
            stream.Position = 0;
            Console.WriteLine("Read file into memory stream");
            
            using var image = new MagickImage(stream);
            if (e.File.ContentType == "image/heif")
            {
                // Convert image to Jpg, flush stream, rewrite image to stream
                image.Format = MagickFormat.Jpg;
                await stream.FlushAsync();
                await image.WriteAsync(stream);
                stream.Position = 0;
            }
            image.Resize(512,512);
            imageBytes = image.ToByteArray();
            imageBase64Data = Convert.ToBase64String(imageBytes);
            imageSource = $"data:image/jpeg;base64,{imageBase64Data}";
            stream.Position = 0;
            
            // Extract EXIF data from stream
            imageMetadata = await new ExifExtractService().ExtractExifData(stream);
            
            _resultMessage = SuccessMessage;

            if (imageMetadata.DateTaken != null)
            {
                _dateTaken = imageMetadata.DateTaken.ToString();
            }
            else
            {
                _dateTaken = NullMetadataMessage;
            }

            if (imageMetadata.Coordinates != null)
            {
                // string? places = null;
                var lat = imageMetadata.Coordinates.Value.Item1.ToString();
                var lng = imageMetadata.Coordinates.Value.Item2.ToString();
                _coordinateString = $"Latitude: {lat} Longitude: {lng}";
                var geocodingData = await googleServices.GeocodingApi(lat,lng);
                
                var searchTerms = geocodingData.Item1;
                var formatedAddresses = geocodingData.Item2;

                _searchTerms = "";

                foreach (var searchTerm in searchTerms)
                {
                    _searchTerms += " " + searchTerm;
                }

                var year = imageMetadata.DateTaken.Year;
                var month = imageMetadata.DateTaken.Month;
                var day = imageMetadata.DateTaken.Day;

                _twitterResultsUrl = $"https://twitter.com/search?q=+geocode%3A{imageMetadata.Coordinates.Value.Item1}%2C{imageMetadata.Coordinates.Value.Item2}%2C2mi+since%3A{year}-{month}-{day-1}+until%3A{year}-{month}-{day+1}&src=typed_query";
                
                _address = await openAIService.AddressCorrection(formatedAddresses, imageBytes);
                _historyOfAddress = await openAIService.HistoryOfAddress(_address);

                var webResults = await googleServices.SearchApi(searchTerms, imageMetadata.DateTaken);

                foreach (var webResult in webResults)
                {
                    Console.WriteLine(webResult.title);
                    Console.WriteLine(webResult.snippet);
                    Console.WriteLine(webResult.link);
                    Console.WriteLine(webResult.thumbnailUrl);
                }
            }
            else
            {
                _coordinateString = NullMetadataMessage;
                _places = NullMetadataMessage;
                _address = NullMetadataMessage;
            }
        }
        catch (ExifLibException ex)
        {
            _resultMessage = $"Error: {ex.Message}";
        }
        catch (Exception ex)
        {
            _resultMessage = $"Error: {ex.Message}";
        }
        
        
    }
}